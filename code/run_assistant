#!/usr/local/bin/node

/*
 * Creates and runs a ChatGPT assistant designed to query NOTAMs
 * 
 * Usage: ./run_assistant 
 *
 * Copyright (c) 2024 Frey Mansikkaniemi
 */

const fs = require('fs');
const readline = require('readline')
const path = require('path');
const openailib = require('openai');
const { throws } = require('assert');
const openai = new openailib.OpenAI()
const dataDirPath = "../data"
const assistantName = "NOTAM Assistant"
const vectorStoreName = "NOTAM Store"
const llmModel = "gpt-3.5-turbo"
    //const llmModel = "gpt-4-turbo-preview"
    //const llmModel = "gpt-4-turbo"

async function createAssistant(instructions) {
    try {
        const assistant = await openai.beta.assistants.create({
            name: assistantName,
            instructions: instructions,
            tools: [{ type: "file_search" }],
            model: "gpt-4-turbo-preview",
            temperature: 0.1,
        });
        return assistant;
    } catch (error) {
        console.error(`Error creating assistant: ${error.message}`);
    }
}

async function getAssistant() {
    const myAssistants = await openai.beta.assistants.list({
        order: "desc",
        limit: "20",
    });

    const theAssistant = myAssistants.data.filter(a => a.name === assistantName)

    if (theAssistant.length === 1) {
        return theAssistant[0];
    } else {
        return null;
    }

}

async function getVectorStore() {
    const stores = await openai.beta.vectorStores.list();
    const theStore = stores.data.filter(s => s.name === vectorStoreName)

    if (theStore.length === 1) {
        return theStore[0];
    } else {
        return null;
    }
}

async function uploadAssistantFiles(files) {
    const fileIds = []

    for (let index = 0; index < files.length; index++) {
        const file = files[index];
        const fileId = await openai.files.create({
            file: fs.createReadStream(file),
            purpose: "assistants",
        });
        fileIds.push(fileId.id)
        console.log("Uploaded: " + fileId.id)

    }
    return fileIds;
}

async function createVectorStore(files) {
    const fileIds = await uploadAssistantFiles(files)

    // Create a vector store including our files.
    let vectorStore = await openai.beta.vectorStores.create({
        name: vectorStoreName,
        file_ids: fileIds,
    });

    return vectorStore;
}

function readFileIntoString(filePath) {
    try {
        const data = fs.readFileSync(filePath, 'utf8');
        return data;
    } catch (error) {
        console.error(`Got an error trying to read the file: ${error.message}`);
    }
}

function writeLineToFile(filePath, line) {
    try {
        fs.appendFileSync(filePath, line + '\n')
    } catch (error) {
        console.error(`Failed to write to the file: ${error.message}`);
    }
}

function createFile(filePath) {
    try {
        fs.writeFileSync(filePath, "")
    } catch (error) {
        console.error(`Failed to write to the file: ${error.message}`);
    }
}

function getNotamFileNames(directory) {
    const fileIds = []

    try {
        const files = fs.readdirSync(directory)

        files.forEach(file => {
            if (path.extname(file) === '.json') {
                const absolutePath = path.resolve(directory, file);
                fileIds.push(absolutePath)
            }
        });

        return fileIds;
    } catch (error) {
        console.error(`Got an error trying to read the directory: ${error.message}`);
    }
}

async function readLinesIntoArray(filePath) {
    const fileStream = fs.createReadStream(filePath);
    const rl = readline.createInterface({
        input: fileStream,
        crlfDelay: Infinity
    });

    const lines = [];

    for await (const line of rl) {
        lines.push(line);
    }

    return lines;
}

function extractICAOIdent(inputString) {
    // Define the regex pattern
    const pattern = / - ([A-Z]{4})/;

    // Use match() to search for the pattern in the input string
    const matches = inputString.match(pattern);

    // Check if the pattern was found
    if (matches && matches.length > 1) {
        // Return the part of the string that matches the pattern inside the parentheses
        return matches[1];
    } else {
        // Return null if the pattern was not found
        return "";
    }
}

function extractNOTAMIdents(text) {
    // Define the regex pattern to match the specified format globally
    const pattern = /[A-Z]\d{2,4}\/\d{2}/g;

    // Search for all matches of the pattern in the text
    const matches = text.match(pattern);

    // Return the matches or indicate no matches were found
    return [...new Set(matches)] || [];
}

async function getQuestions() {
    const lines = await readLinesIntoArray(`${dataDirPath}/questions.txt`)
    return lines;
}

async function getAirports() {
    const lines = await readLinesIntoArray(`${dataDirPath}/airport_list.txt`)
    return lines.map(extractICAOIdent)
}

async function askQuestion(questionText, thread) {
    const message = await openai.beta.threads.messages.create(
        thread.id, {
            role: "user",
            content: "YOUR TASK: " + questionText
        }
    );
    return message;
}

async function getAnswerFromAssistant(assistant, thread) {
    let run = await openai.beta.threads.runs.create(
        thread.id, {
            assistant_id: assistant.id
        }
    );

    while (['queued', 'in_progress', 'cancelling'].includes(run.status)) {
        await new Promise(resolve => setTimeout(resolve, 1000)); // Wait for 1 second
        run = await openai.beta.threads.runs.retrieve(
            run.thread_id,
            run.id
        );
    }

    if (run.status === 'completed') {
        const created_messages = await openai.beta.threads.messages.list(
            run.thread_id
        );
        let messageText = null
        for (const message of created_messages.data.reverse()) {
            //console.log(`${message.role} > ${message.content[0].text.value}`);
            if (message.role == 'assistant') {
                messageText = message.content[0].text.value;
            }
        }
        return messageText;
    } else {
        throw new Error(`Error running thread: ${run.status}`)
    }
}

async function main() {
    const prompt = readFileIntoString(`${dataDirPath}/prompt.txt`);
    console.log("Found prompt")
    const notams = getNotamFileNames(dataDirPath)
    console.log("Found " + notams.length + " NOTAM files")

    let assistant = await getAssistant()

    if (assistant === null) {
        assistant = await createAssistant(prompt)
        console.log("Assistant created, id: " + assistant.id)
        let vectorStore = await getVectorStore()
        if (vectorStore === null) {
            vectorStore = await createVectorStore(notams)
            console.log("Vector Store created, id: ", vectorStore.id)
        } else {
            console.log("Using existing vector store id: " + vectorStore.id)
        }

        await openai.beta.assistants.update(assistant.id, {
            tool_resources: { file_search: { vector_store_ids: [vectorStore.id] } },
        });
        console.log("Updated assistant.")
    } else {
        console.log("Using existing assistant id: " + assistant.id)
    }

    const airports = await getAirports()
    console.log("Found airports", airports)
    const questions = await getQuestions()
    console.log("Found questions", questions)
    const now = new Date()
    const outfile = dataDirPath + "/answers-run-" + now.toISOString().replaceAll(':', '').replaceAll('-', '') + ".md"
    const outfileCsv = dataDirPath + "/answers-run-" + now.toISOString().replaceAll(':', '').replaceAll('-', '') + ".csv"
    createFile(outfile)
    createFile(outfileCsv)

    for (let index_a = 0; index_a < airports.length; index_a++) {
        const airport = airports[index_a];
        //const thread = await openai.beta.threads.create();
        console.log("-------------------------------------------");
        writeLineToFile(outfile, "\n---\n")
        console.log(`Airport: ${airport}`)
        writeLineToFile(outfile, `# Airport: ${airport}`)

        let retrycount = 0;
        for (let index_q = 0; index_q < questions.length; index_q++) {
            const thread = await openai.beta.threads.create();
            const question = questions[index_q];
            if (retrycount > 0) {
                console.log("Retrying question " + index_q)
            }
            writeLineToFile(outfile, "")
                //console.log(`Q${index+1}: ${question}`)
            await askQuestion(question.replace('XXXX', airport), thread);
            const answer = await getAnswerFromAssistant(assistant, thread);
            if (answer === null && retrycount < 10) {
                retrycount += 1;
                index_q -= 1;
            } else {
                console.log(`##A${index_q+1}`)
                    //console.log(`${answer}`)
                const notamIdents = extractNOTAMIdents(answer)
                writeLineToFile(outfile, `## A${index_q+1}:`)
                writeLineToFile(outfile, `${answer}`)
                writeLineToFile(outfileCsv, `${airport},${index_q+1},${notamIdents.join(',')}`)
                retrycount = 0;
            }
        }

    }
    //const response = await openai.beta.assistants.del(assistant.id);
    //console.log("Assistant deleted.")
}

main();